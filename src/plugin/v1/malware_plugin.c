#include <windows.h>
#include <stdio.h>
#include <tlhelp32.h>
#include <psapi.h>

#define FTK_PLUGIN_API __declspec(dllexport)

#pragma comment(lib, "psapi.lib")
#pragma comment(lib, "advapi32.lib")

// 特权常量定义
#define SE_DEBUG_PRIVILEGE (19L)

// 可疑进程名称列表
const char* suspiciousProcesses[] = {
    "mimikatz", "procdump", "psexec", "wce", "gsecdump", 
    "laZagne", "quarkspwdump", "powersploit", "metasploit",
    "cobaltstrike", "beacon", "empire", "invoke", "metsvc"
};
const int suspiciousCount = sizeof(suspiciousProcesses) / sizeof(suspiciousProcesses[0]);

// 检查进程是否具有调试特权
int HasDebugPrivilege(DWORD pid) {
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);
    if (!hProcess) return 0;
    
    HANDLE hToken;
    if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) {
        CloseHandle(hProcess);
        return 0;
    }
    
    DWORD tokenInfoLength = 0;
    GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &tokenInfoLength);
    
    int hasDebug = 0;
    if (tokenInfoLength > 0) {
        PTOKEN_PRIVILEGES tokenPrivileges = (PTOKEN_PRIVILEGES)malloc(tokenInfoLength);
        if (tokenPrivileges && GetTokenInformation(hToken, TokenPrivileges, tokenPrivileges, tokenInfoLength, &tokenInfoLength)) {
            for (DWORD i = 0; i < tokenPrivileges->PrivilegeCount; i++) {
                if (tokenPrivileges->Privileges[i].Luid.LowPart == SE_DEBUG_PRIVILEGE &&
                    (tokenPrivileges->Privileges[i].Attributes & SE_PRIVILEGE_ENABLED)) {
                    hasDebug = 1;
                    break;
                }
            }
        }
        if (tokenPrivileges) free(tokenPrivileges);
    }
    
    CloseHandle(hToken);
    CloseHandle(hProcess);
    return hasDebug;
}

// 检查持久化位置
void CheckPersistenceLocations(void) {
    printf("\n=== 持久化位置检查 ===\n");
    printf("注册表运行键检查:\n");
    
    HKEY hKey;
    const char* runKeys[] = {
        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",
        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
        "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run"
    };
    
    for (int i = 0; i < 3; i++) {
        if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, runKeys[i], 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
            printf("  [√] %s\n", runKeys[i]);
            
            DWORD index = 0;
            char valueName[256];
            char valueData[1024];
            DWORD valueNameSize, valueDataSize, valueType;
            
            while (1) {
                valueNameSize = sizeof(valueName);
                valueDataSize = sizeof(valueData);
                
                if (RegEnumValueA(hKey, index, valueName, &valueNameSize, 
                    NULL, &valueType, (BYTE*)valueData, &valueDataSize) != ERROR_SUCCESS) {
                    break;
                }
                
                if (valueType == REG_SZ) {
                    printf("      %s = %s\n", valueName, valueData);
                }
                
                index++;
            }
            
            RegCloseKey(hKey);
        }
    }
}

FTK_PLUGIN_API int ftk_plugin_init(void) {
    return 0;
}

FTK_PLUGIN_API int ftk_plugin_execute(const char* args) {
    printf("\n=== 恶意代码检测分析 ===\n\n");
    
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("[ERROR] 无法创建进程快照\n");
        return -1;
    }
    
    PROCESSENTRY32 pe;
    pe.dwSize = sizeof(PROCESSENTRY32);
    
    int suspiciousFound = 0;
    
    printf("%-8s %-30s %-15s %s\n", "PID", "进程名", "风险等级", "检测原因");
    printf("----------------------------------------------------------------\n");
    
    if (Process32First(hSnapshot, &pe)) {
        do {
            int riskLevel = 0;
            char reason[256] = {0};
            
            // 检查可疑进程名称
            for (int i = 0; i < suspiciousCount; i++) {
                if (strstr(pe.szExeFile, suspiciousProcesses[i]) != NULL) {
                    riskLevel = 3; // 高风险
                    sprintf_s(reason, sizeof(reason), "匹配已知恶意工具: %s", suspiciousProcesses[i]);
                    break;
                }
            }
            
            // 检查调试特权
            if (riskLevel == 0 && HasDebugPrivilege(pe.th32ProcessID)) {
                riskLevel = 2; // 中风险
                strcpy_s(reason, sizeof(reason), "具有调试特权(SeDebugPrivilege)");
            }
            
            // 检查父进程异常
            if (riskLevel == 0 && pe.th32ParentProcessID != 0) {
                HANDLE hParent = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pe.th32ParentProcessID);
                if (hParent) {
                    char parentPath[MAX_PATH];
                    if (GetModuleFileNameExA(hParent, NULL, parentPath, sizeof(parentPath))) {
                        // 检查是否从异常位置启动
                        if (strstr(parentPath, "Temp") != NULL || 
                            strstr(parentPath, "tmp") != NULL ||
                            strstr(parentPath, "AppData") != NULL) {
                            riskLevel = 1; // 低风险
                            strcpy_s(reason, sizeof(reason), "从临时目录启动");
                        }
                    }
                    CloseHandle(hParent);
                }
            }
            
            if (riskLevel > 0) {
                const char* riskText;
                switch (riskLevel) {
                    case 1: riskText = "低风险"; break;
                    case 2: riskText = "中风险"; break;
                    case 3: riskText = "高风险"; break;
                    default: riskText = "未知";
                }
                
                printf("%-8lu %-30s %-15s %s\n", 
                       pe.th32ProcessID, pe.szExeFile, riskText, reason);
                suspiciousFound++;
            }
            
        } while (Process32Next(hSnapshot, &pe));
    }
    
    CloseHandle(hSnapshot);
    
    if (suspiciousFound == 0) {
        printf("未发现明显的可疑进程\n");
    } else {
        printf("\n总共发现 %d 个可疑进程\n", suspiciousFound);
    }
    
    // 检查常见的持久化位置
    CheckPersistenceLocations();
    
    return 0;
}

FTK_PLUGIN_API void ftk_plugin_help(void) {
    printf("恶意代码检测插件帮助:\n");
    printf("  功能: 检测可疑进程和恶意代码行为\n");
    printf("  用法: malware\n");
    printf("  输出: 可疑进程列表、风险等级、持久化位置检查\n");
}

FTK_PLUGIN_API const char* ftk_plugin_info(void) {
    return "malware|恶意代码检测插件";
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {
    return TRUE;
}